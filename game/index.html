<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gear Wars - Battle Arena</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 840px; /* Slightly more than 800 to account for borders/padding */
        }

        #gameCanvas {
            border: 4px solid #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
            background: #0a0a15;
            border-radius: 10px;
            display: block;
        }

        .hud {
            display: flex;
            justify-content: space-between;
            width: 800px;
            max-width: 100%;
            gap: 20px;
        }

        .player-info {
            flex: 1;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid;
        }

        .player1-info {
            border-color: #00ff88;
        }

        .player2-info {
            border-color: #ff0088;
        }

        .hearts {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .heart {
            width: 25px;
            height: 25px;
            font-size: 25px;
        }

        .stat-bar {
            margin: 8px 0;
        }

        .stat-label {
            font-size: 12px;
            margin-bottom: 3px;
            opacity: 0.8;
        }

        .bar-container {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .bar-fill {
            height: 100%;
            transition: width 0.1s;
            border-radius: 10px;
        }

        .stamina-bar {
            background: linear-gradient(90deg, #00d4ff, #0088ff);
        }

        .heat-bar {
            background: linear-gradient(90deg, #ff6600, #ff0000);
        }

        .controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
            width: 800px;
            max-width: 100%;
        }

        @media (max-width: 800px) {
            .controls {
                display: none;
            }
        }

        .controls h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }

        .control-section {
            display: flex;
            justify-content: space-between;
            gap: 30px;
        }

        .control-column {
            flex: 1;
        }

        .control-item {
            margin: 8px 0;
            font-size: 13px;
        }

        .key {
            display: inline-block;
            background: rgba(0, 212, 255, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            border: 1px solid #00d4ff;
            margin-right: 8px;
            min-width: 60px;
            text-align: center;
        }

        .game-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid #00d4ff;
            font-size: 32px;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.8);
        }

        .countdown {
            font-size: 24px;
            margin-top: 10px;
            color: #00d4ff;
        }

        .timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00d4ff;
        }

        .ability-cooldown {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 3px;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            user-select: none;
            -webkit-user-select: none;
            z-index: 100;
        }

        @media (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
        }

        .d-pad {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            opacity: 0.7;
        }

        .action-buttons {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 150px;
            height: 150px;
            opacity: 0.7;
        }

        .control-btn {
            position: absolute;
            background: rgba(0, 212, 255, 0.3);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            font-size: 18px;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
        }
        
        /* D-Pad layout */
        #d-pad-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #d-pad-down { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #d-pad-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #d-pad-right { top: 50px; right: 0; width: 50px; height: 50px; }
        
        /* Action Button layout */
        #action-boost {
            top: 0; right: 0;
            width: 80px; height: 80px;
            border-radius: 50%;
            font-size: 14px;
        }
        #action-shield {
            bottom: 0; left: 0;
            width: 60px; height: 60px;
            border-radius: 50%;
            font-size: 12px;
        }
        #action-parry {
            bottom: 0; right: 0;
            width: 60px; height: 60px;
            border-radius: 50%;
            font-size: 12px;
        }

        .control-btn:active {
            background: rgba(0, 212, 255, 0.7);
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .hidden {
            display: none !important;
        }

        .screen h1 {
            font-size: 3em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(52, 152, 219, 0.5);
        }

        .screen p {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #bdc3c7;
        }

        .screen button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.1em;
            border-radius: 25px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .screen button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .screen button:active {
            transform: translateY(0);
        }

        .instructions {
            margin-top: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            max-width: 300px;
        }

        .instructions p {
            margin: 10px 0;
            font-size: 0.9em;
            color: #ecf0f1;
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }
            
            .screen h1 {
                font-size: 2.5em;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
                padding: 15px;
                font-size: 20px;
            }
        }

        @media (max-width: 480px) {
            .screen h1 {
                font-size: 2em;
            }
            
            .screen p {
                font-size: 1em;
            }
            
            .screen button {
                padding: 12px 25px;
                font-size: 1em;
            }
        }

        /* Added for better responsiveness */
        @media (max-width: 600px) {
            .hud {
                flex-direction: column;
                gap: 10px;
            }

            .player-info {
                width: 100%;
            }

            body {
                padding: 10px;
            }

            #gameContainer {
                padding: 10px;
                gap: 10px;
            }

            .d-pad {
                bottom: 10px;
                left: 10px;
                width: 120px;
                height: 120px;
            }

            .action-buttons {
                bottom: 10px;
                right: 10px;
                width: 120px;
                height: 120px;
            }

            #d-pad-up { left: 40px; width: 40px; height: 40px; }
            #d-pad-down { left: 40px; width: 40px; height: 40px; }
            #d-pad-left { top: 40px; width: 40px; height: 40px; }
            #d-pad-right { top: 40px; width: 40px; height: 40px; }

            #action-boost {
                width: 64px; height: 64px;
                font-size: 12px;
            }
            #action-shield {
                width: 48px; height: 48px;
                font-size: 10px;
            }
            #action-parry {
                width: 48px; height: 48px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="hud">
            <div class="player-info player1-info">
                <h3>PLAYER 1 (Green)</h3>
                <div class="hearts" id="p1Hearts"></div>
                <div class="stat-bar">
                    <div class="stat-label">STAMINA</div>
                    <div class="bar-container">
                        <div class="bar-fill stamina-bar" id="p1Stamina"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">HEAT METER</div>
                    <div class="bar-container">
                        <div class="bar-fill heat-bar" id="p1Heat"></div>
                    </div>
                </div>
                <div class="ability-cooldown" id="p1Shield">Shield: Ready</div>
                <div class="ability-cooldown" id="p1Boost">Boost: Ready</div>
            </div>

            <div class="player-info player2-info">
                <h3>PLAYER 2 (Pink)</h3>
                <div class="hearts" id="p2Hearts"></div>
                <div class="stat-bar">
                    <div class="stat-label">STAMINA</div>
                    <div class="bar-container">
                        <div class="bar-fill stamina-bar" id="p2Stamina"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">HEAT METER</div>
                    <div class="bar-container">
                        <div class="bar-fill heat-bar" id="p2Heat"></div>
                    </div>
                </div>
                <div class="ability-cooldown" id="p2Shield">Shield: Ready</div>
                <div class="ability-cooldown" id="p2Boost">Boost: Ready</div>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div class="timer" id="gameTimer">5:00</div>
        </div>

        <div class="controls">
            <h3>üéÆ CONTROLS & MECHANICS</h3>
            <div class="control-section">
                <div class="control-column">
                    <div class="control-item"><span class="key">WASD</span> Move Player 1</div>
                    <div class="control-item"><span class="key">SPACE</span> Boost (40 stamina)</div>
                    <div class="control-item"><span class="key">SHIFT</span> Shield (50 stamina, 2 max)</div>
                    <div class="control-item"><span class="key">Q</span> Parry (steal gear on contact)</div>
                </div>
                <div class="control-column">
                    <div class="control-item"><span class="key">‚Üë‚Üì‚Üê‚Üí</span> Move Player 2</div>
                    <div class="control-item"><span class="key">ENTER</span> Boost (40 stamina)</div>
                    <div class="control-item"><span class="key">RSHIFT</span> Shield (50 stamina, 2 max)</div>
                    <div class="control-item"><span class="key">/</span> Parry (steal gear on contact)</div>
                </div>
            </div>
            <div style="margin-top: 15px; font-size: 12px; opacity: 0.8;">
                ‚öôÔ∏è Gears: 2s warning, 5s duration, deal damage on contact<br>
                ‚ù§Ô∏è Hearts: Heal 1 HP | üî• Heat Meter: 100% = Double damage burst<br>
                ‚ö° Corners: Speed boost zones | üõ°Ô∏è Parry: 0.3s window to steal gear
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="d-pad">
            <div class="control-btn" id="d-pad-up">‚ñ≤</div>
            <div class="control-btn" id="d-pad-down">‚ñº</div>
            <div class="control-btn" id="d-pad-left">‚óÄ</div>
            <div class="control-btn" id="d-pad-right">‚ñ∂</div>
        </div>
        <div class="action-buttons">
            <div class="control-btn" id="action-boost">Boost</div>
            <div class="control-btn" id="action-shield">Shield</div>
            <div class="control-btn" id="action-parry">Parry</div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <h1>üéÆ GEAR WARS</h1>
        <p>Advanced Battle Arena</p>
        <button id="startBtn">START BATTLE</button>
        <div class="instructions">
            <p>üéØ Collect <strong>GEARS</strong> to attack</p>
            <p>‚ù§Ô∏è Collect <strong>HEARTS</strong> to heal</p>
            <p>‚ö° Use <strong>BOOST</strong> and <strong>SHIELD</strong></p>
            <p>üõ°Ô∏è <strong>PARRY</strong> to steal gears</p>
            <p>‚öîÔ∏è Destroy your opponent!</p>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen hidden">
        <h1 id="resultTitle">VICTORY!</h1>
        <p id="resultMessage">You defeated the enemy!</p>
        <button id="restartBtn">PLAY AGAIN</button>
        <button id="menuBtn">MAIN MENU</button>
    </div>

    <div class="game-message" id="gameMessage"></div>

    <script>
        // Telegram Web App initialization
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.ready();

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const menuBtn = document.getElementById('menuBtn');

        // Set canvas size
        function resizeCanvas() {
            const aspect = 800 / 600;

            let availWidth = window.innerWidth - 40; // Account for padding
            let availHeight;

            if (window.innerWidth < 600) {
                availHeight = window.innerHeight - 350 - 40; // Taller HUD on stacked, plus mobile controls overlay buffer
            } else {
                availHeight = window.innerHeight - 200 - 40; // HUD + gaps
            }

            let targetWidth = Math.min(800, availWidth);
            let targetHeight = targetWidth / aspect;

            if (targetHeight > availHeight) {
                targetHeight = availHeight;
                targetWidth = targetHeight * aspect;
            }

            canvas.style.width = targetWidth + 'px';
            canvas.style.height = targetHeight + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const GAME_DURATION = 300; // 5 minutes in seconds
        const PLAYER_RADIUS = 20;
        const GEAR_RADIUS = 15;
        const HEART_RADIUS = 12;
        const BOOST_FORCE = 8;
        const MOVE_FORCE = 0.6;
        const FRICTION = 0.98;
        const WALL_BOUNCE = 0.7;
        const GEAR_DURATION = 5000;
        const GEAR_SPAWN_INTERVAL = 8000;
        const HEART_SPAWN_INTERVAL = 15000;
        const PARRY_WINDOW = 300;
        const SHIELD_DURATION = 2000;
        const BOOST_COOLDOWN = 3000;
        const STAMINA_REGEN = 0.3;
        const HEAT_DECAY = 0.15;
        const CORNER_BOOST_ZONE = 80;
        
        // Game state
        let gameTime = GAME_DURATION;
        let gameRunning = false;
        let keys = {};
        
        // Spawn zones for gears (fixed locations)
        const gearSpawnZones = [
            { x: canvas.width/2, y: canvas.height/2 }, // Center
            { x: canvas.width/4, y: canvas.height/4 }, // Top-left
            { x: canvas.width*3/4, y: canvas.height*3/4 }, // Bottom-right
        ];
        
        // Player class
        class Player {
            constructor(x, y, color, controls, isAI = false) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.color = color;
                this.controls = controls;
                this.isAI = isAI;
                this.health = 5;
                this.stamina = 100;
                this.heat = 0;
                this.hasGear = false;
                this.gearTimer = 0;
                this.shielded = false;
                this.shieldCharges = 2;
                this.shieldTimer = 0;
                this.parrying = false;
                this.parryTimer = 0;
                this.boostCooldown = 0;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
            }
            
            update(dt, opponent, gears, hearts) {
                if (this.isAI) {
                    this.updateAI(dt, opponent, gears, hearts);
                } else {
                    this.updatePlayer(dt);
                }
                
                // Update timers
                if (this.gearTimer > 0) {
                    this.gearTimer -= dt;
                    if (this.gearTimer <= 0) {
                        this.hasGear = false;
                    }
                }
                
                if (this.shieldTimer > 0) {
                    this.shieldTimer -= dt;
                    if (this.shieldTimer <= 0) {
                        this.shielded = false;
                    }
                }
                
                if (this.parryTimer > 0) {
                    this.parryTimer -= dt;
                    if (this.parryTimer <= 0) {
                        this.parrying = false;
                    }
                }
                
                if (this.boostCooldown > 0) {
                    this.boostCooldown -= dt;
                }
                
                if (this.invulnerableTimer > 0) {
                    this.invulnerableTimer -= dt;
                    if (this.invulnerableTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                // Stamina regen
                this.stamina = Math.min(100, this.stamina + STAMINA_REGEN);
                
                // Heat decay
                this.heat = Math.max(0, this.heat - HEAT_DECAY);
            }
            
            updatePlayer(dt) {
                // Movement
                if (keys[this.controls.up]) this.vy -= MOVE_FORCE;
                if (keys[this.controls.down]) this.vy += MOVE_FORCE;
                if (keys[this.controls.left]) this.vx -= MOVE_FORCE;
                if (keys[this.controls.right]) this.vx += MOVE_FORCE;
                
                this.applyPhysics(dt);
            }
            
            updateAI(dt, opponent, gears, hearts) {
                // Simple AI behavior
                let targetX = opponent.x;
                let targetY = opponent.y;
                
                // Find nearest gear
                let nearestGear = null;
                let minGearDistance = Infinity;
                
                gears.forEach(gear => {
                    if (!gear.warning) {
                        const dx = this.x - gear.x;
                        const dy = this.y - gear.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minGearDistance) {
                            minGearDistance = distance;
                            nearestGear = gear;
                        }
                    }
                });
                
                // Find nearest heart if health is low
                let nearestHeart = null;
                let minHeartDistance = Infinity;
                
                if (this.health < 3) {
                    hearts.forEach(heart => {
                        const dx = this.x - heart.x;
                        const dy = this.y - heart.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minHeartDistance) {
                            minHeartDistance = distance;
                            nearestHeart = heart;
                        }
                    });
                }
                
                // Prioritize targets
                if (nearestHeart && minHeartDistance < 200) {
                    targetX = nearestHeart.x;
                    targetY = nearestHeart.y;
                } else if (nearestGear && minGearDistance < 300 && !this.hasGear) {
                    targetX = nearestGear.x;
                    targetY = nearestGear.y;
                } else if (opponent.hasGear && !this.hasGear) {
                    // Run away from opponent with gear
                    const dx = this.x - opponent.x;
                    const dy = this.y - opponent.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 150) {
                        targetX = this.x + dx * 2;
                        targetY = this.y + dy * 2;
                    }
                }
                
                // Move toward target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 50) {
                    this.vx += (dx / distance) * MOVE_FORCE;
                    this.vy += (dy / distance) * MOVE_FORCE;
                }
                
                // Random ability usage
                if (Math.random() < 0.01 && this.stamina >= 40 && this.boostCooldown <= 0) {
                    this.boost();
                }
                if (Math.random() < 0.005 && opponent.hasGear && this.shieldCharges > 0 && this.stamina >= 50) {
                    this.activateShield();
                }
                if (Math.random() < 0.008 && opponent.hasGear && distance < 100) {
                    this.activateParry();
                }
                
                this.applyPhysics(dt);
            }
            
            applyPhysics(dt) {
                // Apply friction
                this.vx *= FRICTION;
                this.vy *= FRICTION;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Wall collision
                if (this.x - PLAYER_RADIUS < 0) {
                    this.x = PLAYER_RADIUS;
                    this.vx *= -WALL_BOUNCE;
                }
                if (this.x + PLAYER_RADIUS > canvas.width) {
                    this.x = canvas.width - PLAYER_RADIUS;
                    this.vx *= -WALL_BOUNCE;
                }
                if (this.y - PLAYER_RADIUS < 0) {
                    this.y = PLAYER_RADIUS;
                    this.vy *= -WALL_BOUNCE;
                }
                if (this.y + PLAYER_RADIUS > canvas.height) {
                    this.y = canvas.height - PLAYER_RADIUS;
                    this.vy *= -WALL_BOUNCE;
                }
                
                // Corner speed boost
                const inCorner = (this.x < CORNER_BOOST_ZONE || this.x > canvas.width - CORNER_BOOST_ZONE) &&
                                (this.y < CORNER_BOOST_ZONE || this.y > canvas.height - CORNER_BOOST_ZONE);
                if (inCorner) {
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (speed > 0.5) {
                        this.vx *= 1.02;
                        this.vy *= 1.02;
                    }
                }
            }
            
            boost() {
                if (this.stamina >= 40 && this.boostCooldown <= 0) {
                    const angle = Math.atan2(this.vy, this.vx) || 0;
                    this.vx += Math.cos(angle) * BOOST_FORCE + (Math.random() - 0.5) * 2;
                    this.vy += Math.sin(angle) * BOOST_FORCE + (Math.random() - 0.5) * 2;
                    this.stamina -= 40;
                    this.boostCooldown = BOOST_COOLDOWN;
                }
            }
            
            activateShield() {
                if (this.stamina >= 50 && this.shieldCharges > 0) {
                    this.shielded = true;
                    this.shieldTimer = SHIELD_DURATION;
                    this.shieldCharges--;
                    this.stamina -= 50;
                }
            }
            
            activateParry() {
                if (!this.parrying) {
                    this.parrying = true;
                    this.parryTimer = PARRY_WINDOW;
                }
            }
            
            takeDamage(amount) {
                if (!this.shielded && !this.invulnerable) {
                    this.health -= amount;
                    this.invulnerable = true;
                    this.invulnerableTimer = 500; // 0.5s invulnerability
                    return true;
                } else if (this.shielded) {
                    this.shielded = false;
                    this.shieldTimer = 0;
                }
                return false;
            }
            
            draw() {
                ctx.save();
                
                // Draw player circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, PLAYER_RADIUS, 0, Math.PI * 2);
                
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }
                
                if (this.hasGear) {
                    // Draw sawblade teeth
                    const teeth = 12;
                    for (let i = 0; i < teeth; i++) {
                        const angle = (i / teeth) * Math.PI * 2 + Date.now() / 100;
                        const x1 = this.x + Math.cos(angle) * PLAYER_RADIUS;
                        const y1 = this.y + Math.sin(angle) * PLAYER_RADIUS;
                        const x2 = this.x + Math.cos(angle) * (PLAYER_RADIUS + 8);
                        const y2 = this.y + Math.sin(angle) * (PLAYER_RADIUS + 8);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    ctx.fillStyle = '#ff3300';
                } else {
                    ctx.fillStyle = this.color;
                }
                
                ctx.fill();
                
                // Shield effect
                if (this.shielded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, PLAYER_RADIUS + 8, 0, Math.PI * 2);
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Parry indicator
                if (this.parrying) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, PLAYER_RADIUS + 12, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Heat meter visual (glow when at 100%)
                if (this.heat >= 100) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, PLAYER_RADIUS + 5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                ctx.restore();
            }
        }
        
        // Gear class
        class Gear {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = GEAR_RADIUS;
                this.warning = true;
                this.warningTimer = 2000;
            }
            
            update(dt) {
                if (this.warningTimer > 0) {
                    this.warningTimer -= dt;
                    if (this.warningTimer <= 0) {
                        this.warning = false;
                    }
                }
            }
            
            draw() {
                if (this.warning) {
                    // Warning indicator
                    const alpha = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 40, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#ffff00';
                    ctx.textAlign = 'center';
                    ctx.fillText('GEAR', this.x, this.y - 50);
                    ctx.fillText((this.warningTimer / 1000).toFixed(1) + 's', this.x, this.y + 60);
                    ctx.restore();
                } else {
                    // Actual gear
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(Date.now() / 200);
                    ctx.fillStyle = '#ff6600';
                    
                    const teeth = 8;
                    ctx.beginPath();
                    for (let i = 0; i < teeth; i++) {
                        const angle = (i / teeth) * Math.PI * 2;
                        const nextAngle = ((i + 1) / teeth) * Math.PI * 2;
                        const outerRadius = this.radius;
                        const innerRadius = this.radius * 0.6;
                        
                        ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                        ctx.lineTo(Math.cos((angle + nextAngle) / 2) * innerRadius, 
                                  Math.sin((angle + nextAngle) / 2) * innerRadius);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        // Heart class
        class Heart {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = HEART_RADIUS;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(1, 1 + Math.sin(Date.now() / 200) * 0.1);
                ctx.fillStyle = '#ff0088';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ù§Ô∏è', 0, 0);
                ctx.restore();
            }
        }
        
        // Game objects
        let player1, player2, gears, hearts;
        let gearSpawnTimer = GEAR_SPAWN_INTERVAL;
        let heartSpawnTimer = HEART_SPAWN_INTERVAL;
        
        // Input handling
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Player 1 abilities
            if (e.key === ' ') {
                e.preventDefault();
                player1.boost();
            }
            if (e.key === 'Shift') {
                player1.activateShield();
            }
            if (e.key === 'q') {
                player1.activateParry();
            }
            
            // Player 2 abilities
            if (e.key === 'Enter') {
                e.preventDefault();
                if (!player2.isAI) player2.boost();
            }
            if (e.key === 'ShiftRight') {
                if (!player2.isAI) player2.activateShield();
            }
            if (e.key === '/') {
                if (!player2.isAI) player2.activateParry();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Mobile Controls
        function setupMobileControls() {
            const dPadUp = document.getElementById('d-pad-up');
            const dPadDown = document.getElementById('d-pad-down');
            const dPadLeft = document.getElementById('d-pad-left');
            const dPadRight = document.getElementById('d-pad-right');

            dPadUp.addEventListener('touchstart', (e) => { e.preventDefault(); keys['w'] = true; }, { passive: false });
            dPadUp.addEventListener('touchend', (e) => { e.preventDefault(); keys['w'] = false; });

            dPadDown.addEventListener('touchstart', (e) => { e.preventDefault(); keys['s'] = true; }, { passive: false });
            dPadDown.addEventListener('touchend', (e) => { e.preventDefault(); keys['s'] = false; });

            dPadLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys['a'] = true; }, { passive: false });
            dPadLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys['a'] = false; });

            dPadRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys['d'] = true; }, { passive: false });
            dPadRight.addEventListener('touchend', (e) => { e.preventDefault(); keys['d'] = false; });

            const boostBtn = document.getElementById('action-boost');
            const shieldBtn = document.getElementById('action-shield');
            const parryBtn = document.getElementById('action-parry');

            boostBtn.addEventListener('touchstart', (e) => { e.preventDefault(); player1.boost(); }, { passive: false });
            shieldBtn.addEventListener('touchstart', (e) => { e.preventDefault(); player1.activateShield(); }, { passive: false });
            parryBtn.addEventListener('touchstart', (e) => { e.preventDefault(); player1.activateParry(); }, { passive: false });
            
            // Add active states for visual feedback
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    btn.style.background = 'rgba(0, 212, 255, 0.7)';
                }, { passive: false });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    btn.style.background = 'rgba(0, 212, 255, 0.3)';
                });
            });
        }
        
        // Collision detection
        function checkCollision(obj1, obj2, r1, r2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < r1 + r2;
        }
        
        // Update HUD
        function updateHUD() {
            // Hearts
            document.getElementById('p1Hearts').innerHTML = '‚ù§Ô∏è'.repeat(player1.health) + 'üñ§'.repeat(5 - player1.health);
            document.getElementById('p2Hearts').innerHTML = '‚ù§Ô∏è'.repeat(player2.health) + 'üñ§'.repeat(5 - player2.health);
            
            // Stamina
            document.getElementById('p1Stamina').style.width = player1.stamina + '%';
            document.getElementById('p2Stamina').style.width = player2.stamina + '%';
            
            // Heat
            document.getElementById('p1Heat').style.width = player1.heat + '%';
            document.getElementById('p2Heat').style.width = player2.heat + '%';
            
            // Abilities
            const p1ShieldText = player1.shielded ? 'Shield: ACTIVE' : 
                               player1.shieldCharges === 0 ? 'Shield: NONE' :
                               player1.stamina < 50 ? `Shield: ${player1.shieldCharges} (Need 50 stamina)` :
                               `Shield: ${player1.shieldCharges} Ready`;
            document.getElementById('p1Shield').textContent = p1ShieldText;
            
            const p2ShieldText = player2.shielded ? 'Shield: ACTIVE' : 
                               player2.shieldCharges === 0 ? 'Shield: NONE' :
                               player2.stamina < 50 ? `Shield: ${player2.shieldCharges} (Need 50 stamina)` :
                               `Shield: ${player2.shieldCharges} Ready`;
            document.getElementById('p2Shield').textContent = p2ShieldText;
            
            const p1BoostText = player1.boostCooldown > 0 ? `Boost: ${(player1.boostCooldown / 1000).toFixed(1)}s` :
                              player1.stamina < 40 ? 'Boost: Need 40 stamina' : 'Boost: Ready';
            document.getElementById('p1Boost').textContent = p1BoostText;
            
            const p2BoostText = player2.boostCooldown > 0 ? `Boost: ${(player2.boostCooldown / 1000).toFixed(1)}s` :
                              player2.stamina < 40 ? 'Boost: Need 40 stamina' : 'Boost: Ready';
            document.getElementById('p2Boost').textContent = p2BoostText;
            
            // Timer
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            document.getElementById('gameTimer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Draw corner boost zones
        function drawCornerZones() {
            ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
            ctx.fillRect(0, 0, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.fillRect(canvas.width - CORNER_BOOST_ZONE, 0, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.fillRect(0, canvas.height - CORNER_BOOST_ZONE, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.fillRect(canvas.width - CORNER_BOOST_ZONE, canvas.height - CORNER_BOOST_ZONE, 
                        CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(0, 0, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.strokeRect(canvas.width - CORNER_BOOST_ZONE, 0, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.strokeRect(0, canvas.height - CORNER_BOOST_ZONE, CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.strokeRect(canvas.width - CORNER_BOOST_ZONE, canvas.height - CORNER_BOOST_ZONE, 
                          CORNER_BOOST_ZONE, CORNER_BOOST_ZONE);
            ctx.setLineDash([]);
        }

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            const currentTime = Date.now();
            const dt = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!gameRunning) return;
            
            // Update game time
            gameTime -= dt / 1000;
            if (gameTime <= 0) {
                endGame();
                return;
            }
            
            // Clear canvas
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw corner zones
            drawCornerZones();
            
            // Update players
            player1.update(dt, player2, gears, hearts);
            player2.update(dt, player1, gears, hearts);
            
            // Player collision
            if (checkCollision(player1, player2, PLAYER_RADIUS, PLAYER_RADIUS)) {
                const dx = player2.x - player1.x;
                const dy = player2.y - player1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const overlap = PLAYER_RADIUS * 2 - distance;
                
                // Separate players
                const separateX = (dx / distance) * overlap / 2;
                const separateY = (dy / distance) * overlap / 2;
                
                player1.x -= separateX;
                player1.y -= separateY;
                player2.x += separateX;
                player2.y += separateY;
                
                // Bounce
                const tempVx = player1.vx;
                const tempVy = player1.vy;
                player1.vx = player2.vx * 0.5;
                player1.vy = player2.vy * 0.5;
                player2.vx = tempVx * 0.5;
                player2.vy = tempVy * 0.5;
                
                // Parry system
                if (player1.parrying && player2.hasGear) {
                    player1.hasGear = true;
                    player1.gearTimer = GEAR_DURATION;
                    player2.hasGear = false;
                    player2.gearTimer = 0;
                    player1.parrying = false;
                    player2.invulnerable = true;
                    player2.invulnerableTimer = 1000;
                } else if (player2.parrying && player1.hasGear) {
                    player2.hasGear = true;
                    player2.gearTimer = GEAR_DURATION;
                    player1.hasGear = false;
                    player1.gearTimer = 0;
                    player2.parrying = false;
                    player1.invulnerable = true;
                    player1.invulnerableTimer = 1000;
                }
                // Gear damage
                else if (player1.hasGear && !player2.hasGear) {
                    const damageMultiplier = player1.heat >= 100 ? 2 : 1;
                    if (player2.takeDamage(1 * damageMultiplier)) {
                        player1.heat = Math.min(100, player1.heat + 20);
                        if (player1.heat >= 100) {
                            player1.heat = 0; // Reset after burst
                        }
                    }
                } else if (player2.hasGear && !player1.hasGear) {
                    const damageMultiplier = player2.heat >= 100 ? 2 : 1;
                    if (player1.takeDamage(1 * damageMultiplier)) {
                        player2.heat = Math.min(100, player2.heat + 20);
                        if (player2.heat >= 100) {
                            player2.heat = 0; // Reset after burst
                        }
                    }
                }
            }
            
            // Update and draw gears
            gearSpawnTimer -= dt;
            if (gearSpawnTimer <= 0 && gears.length < 2) {
                const zone = gearSpawnZones[Math.floor(Math.random() * gearSpawnZones.length)];
                gears.push(new Gear(zone.x, zone.y));
                gearSpawnTimer = GEAR_SPAWN_INTERVAL;
            }
            
            gears = gears.filter(gear => {
                gear.update(dt);
                
                if (!gear.warning) {
                    // Check collision with players
                    if (checkCollision(player1, gear, PLAYER_RADIUS, GEAR_RADIUS)) {
                        player1.hasGear = true;
                        player1.gearTimer = GEAR_DURATION;
                        return false;
                    }
                    if (checkCollision(player2, gear, PLAYER_RADIUS, GEAR_RADIUS)) {
                        player2.hasGear = true;
                        player2.gearTimer = GEAR_DURATION;
                        return false;
                    }
                }
                
                gear.draw();
                return true;
            });
            
            // Update and draw hearts
            heartSpawnTimer -= dt;
            if (heartSpawnTimer <= 0 && hearts.length < 1) {
                hearts.push(new Heart(
                    Math.random() * (canvas.width - 100) + 50,
                    Math.random() * (canvas.height - 100) + 50
                ));
                heartSpawnTimer = HEART_SPAWN_INTERVAL;
            }
            
            hearts = hearts.filter(heart => {
                // Check collision with players
                if (checkCollision(player1, heart, PLAYER_RADIUS, HEART_RADIUS)) {
                    player1.health = Math.min(5, player1.health + 1);
                    return false;
                }
                if (checkCollision(player2, heart, PLAYER_RADIUS, HEART_RADIUS)) {
                    player2.health = Math.min(5, player2.health + 1);
                    return false;
                }
                
                heart.draw();
                return true;
            });
            
            // Draw players
            player1.draw();
            player2.draw();
            
            // Update HUD
            updateHUD();
            
            // Check for game over
            if (player1.health <= 0 || player2.health <= 0) {
                endGame();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            gameRunning = false;
            
            const resultTitle = document.getElementById('resultTitle');
            const resultMessage = document.getElementById('resultMessage');
            
            let winner = '';
            let resultType = '';
            
            if (player1.health <= 0) {
                winner = 'DEFEAT! üíÄ';
                resultMessage.textContent = 'The enemy was too strong!';
                resultType = 'ai';
            } else if (player2.health <= 0) {
                winner = 'VICTORY! üèÜ';
                resultMessage.textContent = 'You defeated the enemy!';
                resultType = 'player';
            } else {
                // Time ran out, compare health
                if (player1.health > player2.health) {
                    winner = 'VICTORY! üèÜ';
                    resultMessage.textContent = 'Higher Health';
                    resultType = 'player';
                } else if (player2.health > player1.health) {
                    winner = 'DEFEAT! üíÄ';
                    resultMessage.textContent = 'Lower Health';
                    resultType = 'ai';
                } else {
                    winner = 'DRAW! ü§ù';
                    resultMessage.textContent = 'Equal Health';
                    resultType = 'draw';
                }
            }
            
            resultTitle.textContent = winner;
            gameOverScreen.classList.remove('hidden');
            
            // Send result to bot
            try {
                tg.sendData(JSON.stringify({
                    type: 'game_result',
                    winner: resultType,
                    timestamp: Date.now()
                }));
            } catch (e) {
                console.log('Could not send game result to bot');
            }
        }
        
        // Screen management
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        menuBtn.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            // Reset game state
            gameTime = GAME_DURATION;
            gameRunning = true;
            
            // Initialize players
            player1 = new Player(canvas.width/4, canvas.height/2, '#00ff88', {
                up: 'w', down: 's', left: 'a', right: 'd',
                boost: ' ', shield: 'Shift', parry: 'q'
            });
            
            player2 = new Player(canvas.width*3/4, canvas.height/2, '#ff0088', {
                up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight',
                boost: 'Enter', shield: 'ShiftRight', parry: '/'
            }, true); // AI opponent
            
            gears = [];
            hearts = [];
            gearSpawnTimer = GEAR_SPAWN_INTERVAL;
            heartSpawnTimer = HEART_SPAWN_INTERVAL;
            
            // Start countdown
            const messageEl = document.getElementById('gameMessage');
            let countdown = 3;
            
            messageEl.innerHTML = `GET READY<div class="countdown">${countdown}</div>`;
            messageEl.style.display = 'block';
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    messageEl.innerHTML = `GET READY<div class="countdown">${countdown}</div>`;
                } else {
                    messageEl.innerHTML = `GO!`;
                    setTimeout(() => {
                        messageEl.style.display = 'none';
                        lastTime = Date.now();
                        gameLoop();
                    }, 500);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize the game
        setupMobileControls();
        // Game starts from the start screen
    </script>
</body>
    </html>
