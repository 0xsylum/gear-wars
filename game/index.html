<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Gear Wars - Battle Arena</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      color: #fff;
      overflow: hidden;
    }
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
      width: 100%;
      max-width: 840px;
    }
    #gameCanvas {
      border: 4px solid #00d4ff;
      box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
      background: #0a0a15;
      border-radius: 10px;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      width: 800px;
      max-width: 100%;
      gap: 20px;
    }
    .player-info {
      flex: 1;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid;
      transition: all 0.3s ease;
    }
    .player1-info { border-color: #00ff88; }
    .player2-info { border-color: #ff0088; }
    .hearts { display: flex; gap: 5px; margin: 10px 0; }
    .heart { width: 25px; height: 25px; font-size: 25px; }
    .heart.empty::before { content: '‚ô°'; opacity: 0.3; }
    .stat-bar { margin: 8px 0; }
    .bar-container {
      width: 100%; height: 20px;
      background: rgba(255,255,255,0.1);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .bar-fill { height: 100%; transition: width 0.1s; border-radius: 10px; }
    .screen {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 100;
      backdrop-filter: blur(10px);
    }
    .hidden { display: none !important; }
    .screen h1 { font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 20px currentColor; }
    .screen button {
      background: linear-gradient(45deg, #00d4ff, #0088ff);
      border: none; color: white;
      padding: 15px 40px; font-size: 1.2em;
      border-radius: 25px; cursor: pointer;
      margin: 10px; box-shadow: 0 10px 30px rgba(0,212,255,0.4);
      transition: all 0.3s;
    }
    .screen button:hover { transform: translateY(-3px); box-shadow: 0 15px 40px rgba(0,212,255,0.6); }
    #gameMessage { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 4em; z-index: 50; }
    .countdown { font-size: 0.5em; display: block; }
    
    /* MOBILE CONTROLS - FULLY FIXED */
    #mobileControls {
      position: fixed; bottom: 20px; left: 20px;
      display: flex; gap: 15px; z-index: 10;
    }
    @media (min-width: 801px) { #mobileControls { display: none; } }
    .control-btn {
      width: 70px; height: 70px;
      background: rgba(0,212,255,0.8);
      border: none; border-radius: 50%;
      color: white; font-size: 24px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      transition: all 0.1s;
    }
    .control-btn:active { transform: scale(0.9); background: rgba(0,212,255,1); }
    .dpad { display: grid; grid-template: 1fr 1fr / 1fr 1fr; gap: 10px; }
    #mobileControls button:nth-child(1) { grid-area: 1/2; }
    #mobileControls button:nth-child(2) { grid-area: 2/1; }
    #mobileControls button:nth-child(3) { grid-area: 2/2; }
    .actions { display: flex; flex-direction: column; gap: 15px; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div class="hud">
      <div id="player1Info" class="player-info player1-info">
        <div>You</div>
        <div class="hearts" id="p1Hearts"></div>
        <div class="stat-bar"><span class="stat-label">Gear:</span><div class="bar-container"><div id="p1Gear" class="bar-fill" style="width:0%;background:#f1c40f"></div></div></div>
      </div>
      <div style="font-size:2em;font-weight:bold;" id="timer">60</div>
      <div id="player2Info" class="player-info player2-info">
        <div>Enemy</div>
        <div class="hearts" id="p2Hearts"></div>
        <div class="stat-bar"><span class="stat-label">Gear:</span><div class="bar-container"><div id="p2Gear" class="bar-fill" style="width:0%;background:#f1c40f"></div></div></div>
      </div>
    </div>
    <canvas id="gameCanvas"></canvas>
  </div>

  <!-- SCREENS -->
  <div id="startScreen" class="screen">
    <h1>‚öôÔ∏è GEAR WARS</h1>
    <p>Collect gears to attack!<br>Survive 60 seconds</p>
    <button id="startBtn">üöÄ BATTLE</button>
  </div>
  
  <div id="gameOverScreen" class="screen hidden">
    <h1 id="resultTitle">VICTORY!</h1>
    <p id="resultMessage">You defeated the enemy!</p>
    <button id="restartBtn">üîÑ Rematch</button>
    <button id="menuBtn">üè† Menu</button>
  </div>

  <div id="gameMessage" style="display:none;"></div>

  <!-- MOBILE CONTROLS -->
  <div id="mobileControls">
    <div class="dpad">
      <button id="up">‚Üë</button>
      <button id="left">‚Üê</button>
      <button id="down">‚Üì</button>
      <button id="right">‚Üí</button>
    </div>
    <div class="actions">
      <button id="gearBtn">‚öôÔ∏è</button>
    </div>
  </div>

  <script>
    // TELEGRAM INIT
    const tg = window.Telegram.WebApp;
    tg.expand(); tg.ready();

    // GAME SETUP
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const size = Math.min(800, window.innerWidth - 40, window.innerHeight - 200);
      canvas.width = size;
      canvas.height = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // GAME STATE
    let gameState = {
      players: [],
      powerUps: [],
      particles: [],
      gameTime: 60,
      isMultiplayer: false,
      gameId: null,
      myPlayerIndex: 0,
      shake: 0
    };
    let keys = {};
    let gameRunning = false;
    let lastTime = 0;

    // UI ELEMENTS
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const menuBtn = document.getElementById('menuBtn');

    // MULTIPLAYER - FULLY FIXED
    class MultiplayerManager {
      constructor() {
        this.ws = null;
        this.playerId = null;
        this.roomId = null;
      }
      
      connect(gameId) {
        this.ws = new WebSocket(`${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}`);
        
        this.ws.onopen = () => {
          console.log('WS Connected');
          if (gameId) {
            this.ws.send(JSON.stringify({ type: 'join_room', roomId: gameId }));
            gameState.isMultiplayer = true;
            gameState.gameId = gameId;
          }
        };
        
        this.ws.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === 'game_start') {
            gameState.isMultiplayer = true;
            startGame(); // Auto-start multiplayer
          } else if (msg.type === 'game_update') {
            // Sync opponent position/gear
            const opponentIndex = gameState.myPlayerIndex === 0 ? 1 : 0;
            const opp = msg.state;
            gameState.players[opponentIndex].x = opp.x;
            gameState.players[opponentIndex].y = opp.y;
            gameState.players[opponentIndex].gearTime = opp.gearTime;
          } else if (msg.type === 'player_left') {
            endGame(gameState.myPlayerIndex); // Win by default
          }
        };
        
        this.ws.onclose = () => console.log('WS Disconnected');
      }
      
      sendState() {
        if (this.ws && this.ws.readyState === WebSocket.OPEN && gameState.isMultiplayer) {
          this.ws.send(JSON.stringify({
            type: 'game_state',
            state: gameState.players[gameState.myPlayerIndex]
          }));
        }
      }
    }
    
    const multiplayer = new MultiplayerManager();

    // PLAYER CLASS
    class Player {
      constructor(x, y, color, isAI = false) {
        this.x = x;
        this.y = y;
        this.radius = 25;
        this.color = color;
        this.health = 5;
        this.maxHealth = 5;
        this.gearTime = 0;
        this.vx = 0;
        this.vy = 0;
        this.speed = 4;
        this.isAI = isAI;
        this.gearActive = false;
      }
      
      update(dt) {
        // Movement
        if (!this.isAI) {
          this.vx *= 0.85;
          this.vy *= 0.85;
          
          if (keys.left) this.vx -= this.speed * dt;
          if (keys.right) this.vx += this.speed * dt;
          if (keys.up) this.vy -= this.speed * dt;
          if (keys.down) this.vy += this.speed * dt;
        }
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Boundaries
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
        
        // Gear timer
        if (this.gearTime > 0) {
          this.gearTime -= dt;
          this.gearActive = true;
        } else {
          this.gearActive = false;
        }
      }
    }

    // POWERUPS & PARTICLES
    function spawnPowerUp() {
      if (Math.random() < 0.02 && gameState.powerUps.length < 5) {
        gameState.powerUps.push({
          x: Math.random() * (canvas.width - 60) + 30,
          y: Math.random() * (canvas.height - 60) + 30,
          type: Math.random() < 0.6 ? 'gear' : 'heart',
          radius: 15,
          pulse: 0
        });
      }
    }
    
    function checkCollision(p1, p2, r1, r2) {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx*dx + dy*dy) < r1 + r2;
    }
    
    function spawnParticles(x, y, color) {
      for (let i = 0; i < 8; i++) {
        gameState.particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 200,
          vy: (Math.random() - 0.5) * 200,
          life: 1,
          color
        });
      }
    }

    // INPUT HANDLING
    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      e.preventDefault();
    });
    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // MOBILE CONTROLS - FULLY FIXED
    function setupMobileControls() {
      const buttons = ['up', 'down', 'left', 'right'];
      buttons.forEach(dir => {
        const btn = document.getElementById(dir);
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[dir] = true; });
        btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[dir] = false; });
        btn.addEventListener('mousedown', () => keys[dir] = true);
        btn.addEventListener('mouseup', () => keys[dir] = false);
      });
    }
    setupMobileControls();

    // MAIN GAME LOOP
    function gameLoop(currentTime) {
      if (!gameRunning) return;
      
      const dt = (currentTime - lastTime) / 16; // Normalize to 60fps
      lastTime = currentTime;
      
      // Update
      gameState.players.forEach(player => player.update(dt));
      
      // Powerup spawning & collection
      spawnPowerUp();
      for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
        const pu = gameState.powerUps[i];
        pu.pulse += 0.1;
        pu.radius = 15 + Math.sin(pu.pulse) * 2;
        
        gameState.players.forEach((player, idx) => {
          if (checkCollision(player, pu, player.radius, pu.radius)) {
            if (pu.type === 'gear') {
              player.gearTime = 300; // 5 sec @ 60fps
              spawnParticles(pu.x, pu.y, '#f1c40f');
            } else if (pu.type === 'heart' && player.health < player.maxHealth) {
              player.health++;
              spawnParticles(pu.x, pu.y, '#ff4444');
            }
            gameState.powerUps.splice(i, 1);
          }
        });
      }
      
      // Collision damage
      const p1 = gameState.players[0];
      const p2 = gameState.players[1];
      if (checkCollision(p1, p2, p1.radius * (p1.gearActive ? 1.8 : 0.8), p2.radius * (p2.gearActive ? 1.8 : 0.8))) {
        if (p1.gearActive && p2.health > 0) {
          p2.health--;
          spawnParticles(p2.x, p2.y, '#ff4444');
          p1.gearTime *= 0.9; // Bonus for hit
        }
        if (p2.gearActive && p1.health > 0) {
          p1.health--;
          spawnParticles(p1.x, p1.y, '#ff4444');
          p2.gearTime *= 0.9;
        }
      }
      
      // Particles
      gameState.particles = gameState.particles.filter(p => {
        p.x += p.vx * dt / 16;
        p.y += p.vy * dt / 16;
        p.life -= dt / 16;
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
      });
      
      // Multiplayer sync
      if (gameState.isMultiplayer) multiplayer.sendState();
      
      // Check win conditions
      if (p1.health <= 0 || p2.health <= 0 || gameState.gameTime <= 0) {
        endGame(p1.health > p2.health ? 0 : (p2.health > p1.health ? 1 : -1));
        return;
      }
      
      // Timer
      gameState.gameTime -= dt / 60;
      
      // Render
      ctx.save();
      if (gameState.shake > 0) {
        ctx.translate((Math.random() - 0.5) * gameState.shake, (Math.random() - 0.5) * gameState.shake);
        gameState.shake *= 0.9;
      }
      
      ctx.fillStyle = '#0a0a15';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Players
      gameState.players.forEach(player => {
        ctx.save();
        ctx.translate(player.x, player.y);
        
        // Gear glow
        if (player.gearActive) {
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius * 1.5);
          gradient.addColorStop(0, '#ffff00');
          gradient.addColorStop(1, 'transparent');
          ctx.fillStyle = gradient;
          ctx.fillRect(-player.radius * 1.5, -player.radius * 1.5, player.radius * 3, player.radius * 3);
        }
        
        // Player body
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Gear teeth
        if (player.gearActive) {
          ctx.fillStyle = '#ffaa00';
          for (let i = 0; i < 8; i++) {
            ctx.save();
            ctx.rotate((i / 8) * Math.PI * 2);
            ctx.fillRect(0, -4, player.radius + 8, 8);
            ctx.restore();
          }
        }
        ctx.restore();
      });
      
      // Powerups
      gameState.powerUps.forEach(pu => {
        ctx.save();
        ctx.translate(pu.x, pu.y);
        ctx.fillStyle = pu.type === 'gear' ? '#f1c40f' : '#ff4444';
        ctx.beginPath();
        ctx.arc(0, 0, pu.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      });
      
      // Particles
      gameState.particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
        ctx.restore();
      });
      
      ctx.restore();
      
      requestAnimationFrame(gameLoop);
    }

    function endGame(winnerIndex) {
      gameRunning = false;
      
      let resultTitle, resultMessage, resultType;
      if (gameState.isMultiplayer) {
        resultTitle = winnerIndex === gameState.myPlayerIndex ? 'VICTORY! üèÜ' : 'DEFEAT! üíÄ';
        resultMessage = winnerIndex === gameState.myPlayerIndex ? 'You took their coins!' : 'Better luck next time!';
        resultType = { type: 'game_result', gameId: gameState.gameId, winnerId: gameState.players[gameState.myPlayerIndex === 0 ? gameState.players[0].userId : gameState.players[1].userId] };
      } else {
        resultTitle = winnerIndex === 0 ? 'VICTORY! üèÜ' : 'DEFEAT! üíÄ';
        resultMessage = winnerIndex === 0 ? 'AI Destroyed!' : 'AI was too strong!';
        resultType = { type: 'game_result', winner: winnerIndex === 0 ? 'player' : 'ai' };
      }
      
      document.getElementById('resultTitle').textContent = resultTitle;
      document.getElementById('resultMessage').textContent = resultMessage;
      gameOverScreen.classList.remove('hidden');
      
      // Send result to bot
      tg.sendData(JSON.stringify(resultType));
    }

    function startGame() {
      startScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      document.getElementById('gameMessage').style.display = 'none';
      
      // Parse URL params
      const urlParams = new URLSearchParams(window.location.search);
      gameState.gameId = urlParams.get('game');
      const playerSide = urlParams.get('p') || '1';
      gameState.myPlayerIndex = playerSide === '1' ? 0 : 1;
      
      if (gameState.gameId) {
        multiplayer.connect(gameState.gameId);
        // Wait for WS game_start before starting
        return;
      }
      
      // Single player AI
      gameState.isMultiplayer = false;
      gameState.gameTime = 60;
      gameState.players = [
        new Player(canvas.width * 0.25, canvas.height * 0.5, tg.initDataUnsafe.theme_params?.button_color || '#00ff88'),
        new Player(canvas.width * 0.75, canvas.height * 0.5, '#ff0088', true)
      ];
      gameState.powerUps = [];
      gameState.particles = [];
      gameState.shake = 0;
      
      // Countdown
      const msgEl = document.getElementById('gameMessage');
      let countdown = 3;
      msgEl.innerHTML = `<div class="countdown">${countdown}</div>`;
      msgEl.style.display = 'block';
      
      const cdInterval = setInterval(() => {
        countdown--;
        if (countdown > 0) {
          msgEl.innerHTML = `<div class="countdown">${countdown}</div>`;
        } else {
          msgEl.style.display = 'none';
          gameRunning = true;
          lastTime = performance.now();
          requestAnimationFrame(gameLoop);
          clearInterval(cdInterval);
        }
      }, 800);
    }

    // EVENT LISTENERS
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    menuBtn.addEventListener('click', () => {
      tg.close();
    });

    // AUTO START FOR BETS
    if (urlParams.get('game')) {
      startScreen.style.display = 'none';
      startGame();
    }
  </script>
</body>
    </html>
